{"randomArticles":[{"articleTitle":"Momentum和Nesterov Momentum","articleAbstractText":"Momentum momentum即动量，它模拟的是物体运动时的惯性，即更新的时候在一定程度上保留之前更新的方向，同时利用当前batch的梯度微调最终的更新方向。这样一来，可以在一定程度上增加稳定性，从而学习地更快，并且还有一定摆脱局部最优的能力。 具体实现: 需要:学习速率 ϵ, 初始参数 θ, 初始速率v, 动量衰减参数α 每步迭代过程: 从训练集中的随机抽取一批容量为m的样本{x1,\u2026,xm},以及相关的输出yi  计算梯度和误差,并更新速度v和参数θ:  其中参数α表示每回合速率v的衰减程度.如果每次迭代得到的梯度都是g,那么最后得到的v的稳定值为： 也就是说,Momentum最好情况下能够将学习速率加速1/(1−α)倍.一般α的取值有0.5,0.9,0.99这几种，分别表示最大速度2倍，10倍，100倍于SGD的算法。.当然,也可以让α的值随着时间而变化,一开始小点,后来再加大.不过这样一来,又会引进新的参数. 特点:  前后梯度方向一致时,能够加速学习 前后梯度方向不一致时,能够抑制震荡   Nesterov Momentum 这是对传统momentum方法的一项改进，由I....","articleStatus":0,"articlePermalink":"/articles/2021/03/10/1615353529722.html","articleImg1URL":"https://b3logfile.com/file/2021/03/image-6a4ddb64.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Java中的23种设计模式详解","articleAbstractText":"Java中的23种设计模式详解","articleStatus":0,"articlePermalink":"/articles/2018/09/12/1536750662201.html","articleImg1URL":"https://img.hacpai.com/bing/20180725.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"基于Centos7安装CDH6.3.0集群(一)","articleAbstractText":"一 环境准备 这里是CDH对环境的要求：Cloudera Enterprise 6 Requirements and Supported Versions 首先根据需要创建几个虚拟机，我是直接在家里zstack上面创建了6个，分别是common 用来安装公共的数据库和时间同步服务等，上面有docker环境，然后两个master和三个node，配置如下：  在机器的系统都装好以后开始执行以下操作 1 生成公私钥 [root@commonbase ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in ....","articleStatus":0,"articlePermalink":"/articles/2020/08/29/1598633033724.html","articleImg1URL":"https://b3logfile.com/file/2020/08/image-bffc8c66.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Lambda表达式几个示例","articleAbstractText":"Lambda","articleStatus":0,"articlePermalink":"/articles/2018/05/09/1525867184490.html","articleImg1URL":"https://img.hacpai.com/bing/20181111.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Rust三种iterator(iter,iter_mut,into_iter)的区别","articleAbstractText":"Rust中使用变量的途径有三种，所有权(ownership), 不可变引用(immutable reference) 和可变引用(mutable reference)。如果学习了Rust，我们会发现这三种使用值的办法充斥着Rust的角角落落。在此，我们来研究一下Rust Iterator，及其与这三种方式的联系。 首先，所有的迭代器都实现了 Iterator Trait，而 next方法无疑是 Iterator Trait中最基本的方法。我们来看下它的方法签名：  pub trait Iterator { type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; 　 }  我们可以看到，next方法的参数是 &amp;mut self，也就是 可变的迭代器引用。因此，call next方法的类型一定是一个可变的迭代器，不可变迭代器不能call next方法。 next方法的返回值是 Option&lt;Self::Item&gt;这个 enum，目的是可以让我们判断是否有 next value。如果有下一个值，那....","articleStatus":0,"articlePermalink":"/articles/2020/12/28/1609152963317.html","articleImg1URL":"https://b3logfile.com/bing/20181104.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}