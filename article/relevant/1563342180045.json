{"relevantArticles":[{"articleTitle":"gitlab-runner基于docker19.03.2版本持续集成的实践","articleAbstractText":"首先基础环境为  示例共有两个项目 一个为k8s集群中的环境变量项目，另一个为springboot微服务项目 1环境变量项目的自动部署 先看gitlab-ci的内容 image: gongdear/alpine-ssh:latest stages: - deploy-test - deploy-demo before_script: # 预先装 ssh-agent # 2019-09-19 使用已经安装ssh-agent的镜像 # - 'which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)' # 启动服务 - eval $(ssh-agent -s) # 将私钥写入deploy.key 文件 - echo \"$SSH_PRIVATE_KEY\" &gt; deploy.key # 配置较低权限 - chmod 0600 deploy.key # 注入密钥 - ssh-add deploy.key - mkdir -p ~/.ssh - '[[ -f /.dockerenv ]] &amp;&amp; echo....","articleStatus":0,"articlePermalink":"/articles/2019/09/20/1568959288888.html","articleImg1URL":"https://img.hacpai.com/file/2019/09/image-ff7b8c0a.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"升级Docker到19.03版本后Gitlab-Runner的配置","articleAbstractText":"以前升级docker版本时，多数情况都是兼容旧版的所有特性和功能的 结果在近期的CICD构建中，在ci脚本没有变化的情况下突然所有runner的构建都失败了 随后立即采取以下措施尝试修复  工程版本回退到上一次可用状态 更换runner服务器和容器 更改ci脚本 重启docker服务  均无效 执行构建步骤出现了以往没有出现过的警告信息 最终报错信息 Downloading artifacts for maven-build (280)... Downloading artifacts from coordinator... ok id=280 responseStatus=200 OK token=L9iuC5Ss $ docker build -t $CONTAINER_IMAGE:$IMAGE_VERSION . Cannot connect to the Docker daemon at tcp://docker:2375. Is the docker daemon running? ERROR: Job failed: exit code 1  寻找解决方法 该错误在早期版本....","articleStatus":0,"articlePermalink":"/articles/2019/09/20/1568953350682.html","articleImg1URL":"https://img.hacpai.com/file/2019/09/image-7f3779e1.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"gitlab-runner 安装使用","articleAbstractText":"gitlab-runner 安装使用","articleStatus":0,"articlePermalink":"/articles/2019/08/16/1565937022236.html","articleImg1URL":"https://img.hacpai.com/bing/20190323.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Jenkins+GitLab+Docker+SpringCloud实现可持续自动化微服务","articleAbstractText":"现有混合云平台的场景下，即有线下和线上的环境，又有测试与正式的场景，而且结合了Docker，导致打包内容有所区分，且服务的发布流程复杂起来，手工打包需要在编译阶段就要根据环境到处更改配置，因此纯手工发布增加了实施的难度，需要一个统一的适应各种环境部署的方案。  基于微服务的发布流程 　　手动/自动构建 -&gt; Jenkins 调度 K8S API -＞动态生成 Jenkins Slave pod -＞ Slave pod 拉取 Git 代码／编译／打包镜像 -＞推送到镜像仓库 Harbor -＞ Slave工作完成，Pod 自动销毁 -＞部署到测试或生产 Kubernetes（K8S）平台。 　　上面是理想状况下的将服务编译打包成镜像上传到镜像库后部署到Kubernetes平台的一个流程，但问题是： 我们有线上线下平台，代码在线下GitLab，是出不了外网的，因此线上K8S集群无法拉取代码编译。 Jenkins的master所在服务器是CentOS6.5，没有Docker环境，也没有在K8S集群服务器内，因此无法直接执行docker build镜像和 kubectl apply 发....","articleStatus":0,"articlePermalink":"/articles/2019/08/02/1564735994109.html","articleImg1URL":"https://img.hacpai.com/file/2019/08/14490612ff12a7f04994a00-ec665ed0.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"}]}